<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · MonteCarloMeasurements Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="MonteCarloMeasurements Documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit">MonteCarloMeasurements Documentation</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../overloading/">Supporting new functions</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../comparison/">Linear vs. Monte-Carlo uncertainty propagation</a></li><li><a class="tocitem" href="../performance/">Performance tips</a></li><li><a class="tocitem" href="../advanced_usage/">Advanced usage</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Index-1"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Exported-functions-and-types-1"><a class="docs-heading-anchor" href="#Exported-functions-and-types-1">Exported functions and types</a><a class="docs-heading-anchor-permalink" href="#Exported-functions-and-types-1" title="Permalink"></a></h1><h2 id="Index-1"><a class="docs-heading-anchor" href="#Index-1">Index</a><a class="docs-heading-anchor-permalink" href="#Index-1" title="Permalink"></a></h2><ul><li><a href="#MonteCarloMeasurements.MonteCarloMeasurements"><code>MonteCarloMeasurements.MonteCarloMeasurements</code></a></li><li><a href="#MonteCarloMeasurements.Particles"><code>MonteCarloMeasurements.Particles</code></a></li><li><a href="#MonteCarloMeasurements.StaticParticles"><code>MonteCarloMeasurements.StaticParticles</code></a></li><li><a href="#MonteCarloMeasurements.Workspace"><code>MonteCarloMeasurements.Workspace</code></a></li><li><a href="#MonteCarloMeasurements.Workspace-Tuple{Any, Any}"><code>MonteCarloMeasurements.Workspace</code></a></li><li><a href="#Base.:≈-Tuple{AbstractParticles, AbstractParticles}"><code>Base.:≈</code></a></li><li><a href="#Base.:≉-Tuple{AbstractParticles, AbstractParticles}"><code>Base.:≉</code></a></li><li><a href="#MonteCarloMeasurements.:..-Tuple{Any, Any}"><code>MonteCarloMeasurements.:..</code></a></li><li><a href="#MonteCarloMeasurements.:±"><code>MonteCarloMeasurements.:±</code></a></li><li><a href="#MonteCarloMeasurements.:∓"><code>MonteCarloMeasurements.:∓</code></a></li><li><a href="#MonteCarloMeasurements.:⊞-Tuple{Any, Distributions.Distribution}"><code>MonteCarloMeasurements.:⊞</code></a></li><li><a href="#MonteCarloMeasurements.:⊠-Tuple{Any, Distributions.Distribution}"><code>MonteCarloMeasurements.:⊠</code></a></li><li><a href="../advanced_usage/#MonteCarloMeasurements.array_of_structs"><code>MonteCarloMeasurements.array_of_structs</code></a></li><li><a href="#MonteCarloMeasurements.bootstrap"><code>MonteCarloMeasurements.bootstrap</code></a></li><li><a href="#MonteCarloMeasurements.bootstrap"><code>MonteCarloMeasurements.bootstrap</code></a></li><li><a href="../advanced_usage/#MonteCarloMeasurements.build_container"><code>MonteCarloMeasurements.build_container</code></a></li><li><a href="../advanced_usage/#MonteCarloMeasurements.build_mutable_container"><code>MonteCarloMeasurements.build_mutable_container</code></a></li><li><a href="#MonteCarloMeasurements.bymap-Union{Tuple{F}, Tuple{F, Vararg{Any}}} where F"><code>MonteCarloMeasurements.bymap</code></a></li><li><a href="#MonteCarloMeasurements.bypmap-Union{Tuple{F}, Tuple{F, Vararg{Any}}} where F"><code>MonteCarloMeasurements.bypmap</code></a></li><li><a href="#MonteCarloMeasurements.errorbarplot"><code>MonteCarloMeasurements.errorbarplot</code></a></li><li><a href="#MonteCarloMeasurements.ess-Tuple{AbstractParticles}"><code>MonteCarloMeasurements.ess</code></a></li><li><a href="#MonteCarloMeasurements.has_particles-Tuple{Any}"><code>MonteCarloMeasurements.has_particles</code></a></li><li><a href="../advanced_usage/#MonteCarloMeasurements.has_particles"><code>MonteCarloMeasurements.has_particles</code></a></li><li><a href="#MonteCarloMeasurements.mcplot"><code>MonteCarloMeasurements.mcplot</code></a></li><li><a href="../advanced_usage/#MonteCarloMeasurements.mean_object"><code>MonteCarloMeasurements.mean_object</code></a></li><li><a href="#MonteCarloMeasurements.mean_object-Tuple{AbstractParticles}"><code>MonteCarloMeasurements.mean_object</code></a></li><li><a href="#MonteCarloMeasurements.nominal-Tuple{AbstractParticles}"><code>MonteCarloMeasurements.nominal</code></a></li><li><a href="#MonteCarloMeasurements.outer_product"><code>MonteCarloMeasurements.outer_product</code></a></li><li><a href="#MonteCarloMeasurements.register_primitive"><code>MonteCarloMeasurements.register_primitive</code></a></li><li><a href="#MonteCarloMeasurements.register_primitive_multi"><code>MonteCarloMeasurements.register_primitive_multi</code></a></li><li><a href="#MonteCarloMeasurements.register_primitive_single"><code>MonteCarloMeasurements.register_primitive_single</code></a></li><li><a href="../advanced_usage/#MonteCarloMeasurements.replace_particles"><code>MonteCarloMeasurements.replace_particles</code></a></li><li><a href="#MonteCarloMeasurements.ribbonplot"><code>MonteCarloMeasurements.ribbonplot</code></a></li><li><a href="#MonteCarloMeasurements.set_comparison_function-Tuple{Any}"><code>MonteCarloMeasurements.set_comparison_function</code></a></li><li><a href="#MonteCarloMeasurements.sigmapoints-Tuple{Any, AbstractMatrix}"><code>MonteCarloMeasurements.sigmapoints</code></a></li><li><a href="#MonteCarloMeasurements.systematic_sample"><code>MonteCarloMeasurements.systematic_sample</code></a></li><li><a href="#MonteCarloMeasurements.transform_moments-Tuple{Any, Any, Any}"><code>MonteCarloMeasurements.transform_moments</code></a></li><li><a href="#MonteCarloMeasurements.unsafe_comparisons"><code>MonteCarloMeasurements.unsafe_comparisons</code></a></li><li><a href="#MonteCarloMeasurements.wasserstein-Tuple{AbstractParticles, AbstractParticles, Any}"><code>MonteCarloMeasurements.wasserstein</code></a></li><li><a href="#MonteCarloMeasurements.with_nominal-Tuple{AbstractParticles, Any}"><code>MonteCarloMeasurements.with_nominal</code></a></li><li><a href="#MonteCarloMeasurements.with_workspace-Tuple{Any, Any}"><code>MonteCarloMeasurements.with_workspace</code></a></li><li><a href="#MonteCarloMeasurements.ℂ2ℂ_function-Union{Tuple{T}, Tuple{F}, Tuple{F, Complex{T}}} where {F&lt;:Union{DataType, Function}, T&lt;:AbstractParticles}"><code>MonteCarloMeasurements.ℂ2ℂ_function</code></a></li><li><a href="#MonteCarloMeasurements.ℝⁿ2ℂⁿ_function-Union{Tuple{N}, Tuple{T}, Tuple{F}, Tuple{F, AbstractArray{Particles{T, N}}}} where {F, T, N}"><code>MonteCarloMeasurements.ℝⁿ2ℂⁿ_function</code></a></li><li><a href="#MonteCarloMeasurements.ℝⁿ2ℂⁿ_function-Union{Tuple{N}, Tuple{T}, Tuple{F}, Tuple{F, AbstractArray{StaticParticles{T, N}}}} where {F, T, N}"><code>MonteCarloMeasurements.ℝⁿ2ℂⁿ_function</code></a></li><li><a href="#MonteCarloMeasurements.ℝⁿ2ℝⁿ_function-Union{Tuple{N}, Tuple{T}, Tuple{F}, Tuple{F, AbstractArray{Particles{T, N}}}} where {F, T, N}"><code>MonteCarloMeasurements.ℝⁿ2ℝⁿ_function</code></a></li><li><a href="#MonteCarloMeasurements.ℝⁿ2ℝⁿ_function-Union{Tuple{N}, Tuple{T}, Tuple{F}, Tuple{F, AbstractArray{StaticParticles{T, N}}}} where {F, T, N}"><code>MonteCarloMeasurements.ℝⁿ2ℝⁿ_function</code></a></li><li><a href="#MonteCarloMeasurements.@bymap-Tuple{Any}"><code>MonteCarloMeasurements.@bymap</code></a></li><li><a href="#MonteCarloMeasurements.@bypmap-Tuple{Any}"><code>MonteCarloMeasurements.@bypmap</code></a></li><li><a href="#MonteCarloMeasurements.@prob-Tuple{Any}"><code>MonteCarloMeasurements.@prob</code></a></li><li><a href="#MonteCarloMeasurements.@unsafe-Tuple{Any}"><code>MonteCarloMeasurements.@unsafe</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.MonteCarloMeasurements" href="#MonteCarloMeasurements.MonteCarloMeasurements"><code>MonteCarloMeasurements.MonteCarloMeasurements</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This package facilitates working with probability distributions by means of Monte-Carlo methods, in a way that allows for propagation of probability distributions through functions. This is useful for, e.g.,  nonlinear <a href="https://en.wikipedia.org/wiki/Propagation_of_uncertainty">uncertainty propagation</a>. A variable or parameter might be associated with uncertainty if it is measured or otherwise estimated from data. We provide two core types to represent probability distributions: <code>Particles</code> and <code>StaticParticles</code>, both <code>&lt;: Real</code>. (The name &quot;Particles&quot; comes from the <a href="https://en.wikipedia.org/wiki/Particle_filter">particle-filtering</a> literature.) These types all form a Monte-Carlo approximation of the distribution of a floating point number, i.e., the distribution is represented by samples/particles. <strong>Correlated quantities</strong> are handled as well, see <a href="https://baggepinnen.github.io/MonteCarloMeasurements.jl/stable/#Multivariate-particles-1">multivariate particles</a> below.</p><p>A number of type <code>Particles</code> behaves just as any other <code>Number</code> while partaking in calculations. Particles also behave like a distribution, so after a calculation, an approximation to the <strong>complete distribution</strong> of the output is captured and represented by the output particles. <code>mean</code>, <code>std</code> etc. can be extracted from the particles using the corresponding functions <code>pmean</code> and <code>pstd</code>. <code>Particles</code> also interact with <a href="https://github.com/JuliaStats/Distributions.jl">Distributions.jl</a>, so that you can call, e.g., <code>Normal(p)</code> and get back a <code>Normal</code> type from distributions or <code>fit(Gamma, p)</code> to get a <code>Gamma</code>distribution. Particles can also be asked for <code>maximum/minimum</code>, <code>quantile</code> etc. using functions with a prefix <code>p</code>, i.e., <code>pmaximum</code>. If particles are plotted with <code>plot(p)</code>, a histogram is displayed. This requires Plots.jl. A kernel-density estimate can be obtained by <code>density(p)</code> is StatsPlots.jl is loaded.</p><p><strong>Quick start</strong></p><pre><code class="language-julia">julia&gt; using MonteCarloMeasurements, Plots

julia&gt; a = π ± 0.1 # Construct Gaussian uncertain parameters using ± (\pm)
Particles{Float64,2000}
 3.14159 ± 0.1

julia&gt; b = 2 ∓ 0.1 # ∓ (\mp) creates StaticParticles (with StaticArrays)
StaticParticles{Float64,100}
 2.0 ± 0.0999

julia&gt; pstd(a)      # Ask about statistical properties
0.09999231528930486

julia&gt; sin(a)      # Use them like any real number
Particles{Float64,2000}
 1.2168e-16 ± 0.0995

julia&gt; plot(a)     # Plot them

julia&gt; b = sin.(1:0.1:5) .± 0.1; # Create multivariate uncertain numbers

julia&gt; plot(b)                   # Vectors of particles can be plotted

julia&gt; using Distributions

julia&gt; c = Particles(500, Poisson(3.)) # Create uncertain numbers distributed according to a given distribution
Particles{Int64,500}
 2.882 ± 1.7</code></pre><p>For further help, see the <a href="https://baggepinnen.github.io/MonteCarloMeasurements.jl/stable">documentation</a>, the <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/tree/master/examples">examples folder</a> or the <a href="https://arxiv.org/abs/2001.07625">arXiv paper</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/MonteCarloMeasurements.jl#L1-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.Particles" href="#MonteCarloMeasurements.Particles"><code>MonteCarloMeasurements.Particles</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Particles{T, N} &lt;: AbstractParticles{T, N}</code></pre><p>This type represents uncertainty using a cloud of particles.</p><p><strong>Constructors:</strong></p><ul><li><code>Particles()</code></li><li><code>Particles(N::Integer)</code></li><li><code>Particles([rng::AbstractRNG,] d::Distribution)</code></li><li><code>Particles([rng::AbstractRNG,] N::Integer, d::Distribution; permute=true, systematic=true)</code></li><li><code>Particles(v::Vector{T} where T)</code></li><li><code>Particles(m::Matrix{T} where T)</code>: Creates multivariate particles (Vector{Particles})</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/types.jl#L5-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.StaticParticles" href="#MonteCarloMeasurements.StaticParticles"><code>MonteCarloMeasurements.StaticParticles</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct StaticParticles{T, N} &lt;: AbstractParticles{T, N}</code></pre><p>See <code>?Particles</code> for help. The difference between <code>StaticParticles</code> and <code>Particles</code> is that the <code>StaticParticles</code> store particles in a static vecetor. This makes runtimes much shorter, but compile times longer. See the documentation for some benchmarks. Only recommended for sample sizes of ≲ 300-400</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/types.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.Workspace" href="#MonteCarloMeasurements.Workspace"><code>MonteCarloMeasurements.Workspace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Workspace{T1, T2, T3, T4, T5, T6}</code></pre><p><strong>Arguments:</strong></p><ul><li><code>simple_input</code>: Input object <code>f</code> will be called with, does not contain any particles</li><li><code>simple_result</code>: Simple output from <code>f</code> without particles</li><li><code>result</code>: Complete output of <code>f</code> including particles</li><li><code>buffersetter</code>: Helper function to shift data between objects</li><li><code>resultsetter</code>: Helper function to shift data between objects</li><li><code>f</code>: Function to call</li><li><code>N</code>: Number of particles</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/deconstruct.jl#L295-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.Workspace-Tuple{Any, Any}" href="#MonteCarloMeasurements.Workspace-Tuple{Any, Any}"><code>MonteCarloMeasurements.Workspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Workspace(f, input)</code></pre><p>Create a <code>Workspace</code> object for inputs of type <code>typeof(input)</code>. Useful if <code>input</code> is a structure with fields of type <code>&lt;: AbstractParticles</code> (can be deeply nested). See also <code>with_workspace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/deconstruct.jl#L317-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.:..-Tuple{Any, Any}" href="#MonteCarloMeasurements.:..-Tuple{Any, Any}"><code>MonteCarloMeasurements.:..</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">a .. b</code></pre><p>Creates 2000 <code>Particles</code> with a <code>Uniform</code> distribution between <code>a</code> and <code>b</code>. See also <a href="#MonteCarloMeasurements.:±"><code>±</code></a>, <a href="@ref"><code>⊗</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/particles.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.:±" href="#MonteCarloMeasurements.:±"><code>MonteCarloMeasurements.:±</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">μ ± σ</code></pre><p>Creates 2000 <code>Particles</code> with mean <code>μ</code> and std <code>σ</code>. It can also be used as a unary operator, a mean of 0 is then used with std <code>σ</code>. If <code>μ</code> is a vector, the constructor <code>MvNormal</code> is used, and <code>σ</code> is thus treated as std if it&#39;s a scalar, and variances if it&#39;s a matrix or vector. See also <a href="#MonteCarloMeasurements.:∓"><code>∓</code></a>, <a href="#MonteCarloMeasurements.:..-Tuple{Any, Any}"><code>..</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/particles.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.:∓" href="#MonteCarloMeasurements.:∓"><code>MonteCarloMeasurements.:∓</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">μ ∓ σ</code></pre><p>Creates 100 <code>StaticParticles</code> with mean <code>μ</code> and std <code>σ</code>. It can also be used as a unary operator, a mean of 0 is then used with std <code>σ</code>. If <code>μ</code> is a vector, the constructor <code>MvNormal</code> is used, and <code>σ</code> is thus treated as std if it&#39;s a scalar, and variances if it&#39;s a matrix or vector. See also <a href="#MonteCarloMeasurements.:±"><code>±</code></a>, <a href="@ref"><code>⊗</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/particles.jl#L10-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.:⊞-Tuple{Any, Distributions.Distribution}" href="#MonteCarloMeasurements.:⊞-Tuple{Any, Distributions.Distribution}"><code>MonteCarloMeasurements.:⊞</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">a ⊞ Distribution()</code></pre><p>Adds 2000 <code>Particles</code> sampled from a specified <code>::Distribution</code> to <code>a</code>. Shorthand for <code>a + Particles(Distribution())</code>, e.g., <code>1 ⊞ Binomial(3)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/particles.jl#L44-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.:⊠-Tuple{Any, Distributions.Distribution}" href="#MonteCarloMeasurements.:⊠-Tuple{Any, Distributions.Distribution}"><code>MonteCarloMeasurements.:⊠</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">a ⊠ Distribution()</code></pre><p>Multiplies <code>a</code> by 2000 <code>Particles</code> sampled from a specified <code>::Distribution</code>. Shorthand for <code>a * Particles(Distribution())</code>, e.g., <code>a ⊠ Gamma(1)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/particles.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.bootstrap" href="#MonteCarloMeasurements.bootstrap"><code>MonteCarloMeasurements.bootstrap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bootstrap([rng::AbstractRNG,] p::Particles, n = nparticles(p))</code></pre><p>Return Particles resampled with replacement. <code>n</code> specifies the number of samples to draw. Also works for arrays of Particles, in which case a single set of indices are drawn and used to extract samples from all elements in the array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/resampling.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.bootstrap" href="#MonteCarloMeasurements.bootstrap"><code>MonteCarloMeasurements.bootstrap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bootstrap([rng::AbstractRNG,] p::Particles, n = nparticles(p))</code></pre><p>Return Particles resampled with replacement. <code>n</code> specifies the number of samples to draw. Also works for arrays of Particles, in which case a single set of indices are drawn and used to extract samples from all elements in the array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/resampling.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.bymap-Union{Tuple{F}, Tuple{F, Vararg{Any}}} where F" href="#MonteCarloMeasurements.bymap-Union{Tuple{F}, Tuple{F, Vararg{Any}}} where F"><code>MonteCarloMeasurements.bymap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bymap(f, args...)</code></pre><p>Uncertainty propagation using the <code>map</code> function.</p><p>Call <code>f</code> with particles or vectors of particles by using <code>map</code>. This can be utilized if registering <code>f</code> using <a href="#MonteCarloMeasurements.register_primitive"><code>register_primitive</code></a> fails. See also <a href="#MonteCarloMeasurements.Workspace"><code>Workspace</code></a> if <code>bymap</code> fails.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/bymap.jl#L58-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.bypmap-Union{Tuple{F}, Tuple{F, Vararg{Any}}} where F" href="#MonteCarloMeasurements.bypmap-Union{Tuple{F}, Tuple{F, Vararg{Any}}} where F"><code>MonteCarloMeasurements.bypmap</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Distributed uncertainty propagation using the <code>pmap</code> function. See <a href="#MonteCarloMeasurements.bymap-Union{Tuple{F}, Tuple{F, Vararg{Any}}} where F"><code>bymap</code></a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/bymap.jl#L85-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.errorbarplot" href="#MonteCarloMeasurements.errorbarplot"><code>MonteCarloMeasurements.errorbarplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">errorbarplot(x,y,[q=0.025])</code></pre><p>Plots a vector of particles with error bars at quantile <code>q</code>. If <code>q::Tuple</code>, then you can specify both lower and upper quantile, e.g., <code>(0.01, 0.99)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/plotting.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.ess-Tuple{AbstractParticles}" href="#MonteCarloMeasurements.ess-Tuple{AbstractParticles}"><code>MonteCarloMeasurements.ess</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ess(p::AbstractParticles{T,N})</code></pre><p>Calculates the effective sample size. This is useful if particles come from MCMC sampling and are correlated in time. The ESS is a number between [0,N].</p><p>Initial source: https://github.com/tpapp/MCMCDiagnostics.jl</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/sampling.jl#L19-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.has_particles-Tuple{Any}" href="#MonteCarloMeasurements.has_particles-Tuple{Any}"><code>MonteCarloMeasurements.has_particles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_particles(P)</code></pre><p>Determine whether or no the object <code>P</code> has some kind of particles inside it. This function examins fields of <code>P</code> recursively and looks inside arrays etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/deconstruct.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.mcplot" href="#MonteCarloMeasurements.mcplot"><code>MonteCarloMeasurements.mcplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mcplot(x,y,[N=0])</code></pre><p>Plots all trajectories represented by a vector of particles. <code>N &gt; 1</code> controls the number of trajectories to plot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/plotting.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.mean_object-Tuple{AbstractParticles}" href="#MonteCarloMeasurements.mean_object-Tuple{AbstractParticles}"><code>MonteCarloMeasurements.mean_object</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mean_object(x)</code></pre><p>Returns an object similar to <code>x</code>, but where all internal instances of <code>Particles</code> are replaced with their mean. The generalization of this function is <code>replace_particles</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/deconstruct.jl#L89-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.nominal-Tuple{AbstractParticles}" href="#MonteCarloMeasurements.nominal-Tuple{AbstractParticles}"><code>MonteCarloMeasurements.nominal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nominal(p)</code></pre><p>Return the nominal value of <code>p</code> (assumes that <code>p</code> has been endowed with a nominal value using <code>with_nominal</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/nominal.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.outer_product" href="#MonteCarloMeasurements.outer_product"><code>MonteCarloMeasurements.outer_product</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">p = outer_product([rng::AbstractRNG,] dists::Vector{&lt;:Distribution}, N=100_000)</code></pre><p>Creates a multivariate systematic sample where each dimension is sampled according to the corresponding univariate distribution in <code>dists</code>. Returns <code>p::Vector{Particles}</code> where each Particles has a length approximately equal to <code>N</code>. The particles form the outer product between <code>d</code> systematically sampled vectors with length given by the d:th root of N, where <code>d</code> is the length of <code>dists</code>, All particles will be independent and have marginal distributions given by <code>dists</code>.</p><p>See also <code>MonteCarloMeasurements.⊗</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/particles.jl#L59-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.register_primitive" href="#MonteCarloMeasurements.register_primitive"><code>MonteCarloMeasurements.register_primitive</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">register_primitive(f, eval=eval)</code></pre><p>Register both single and multi-argument function so that it works with particles. If you want to register functions from within a module, you must pass the modules <code>eval</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/register_primitive.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.register_primitive_multi" href="#MonteCarloMeasurements.register_primitive_multi"><code>MonteCarloMeasurements.register_primitive_multi</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">register_primitive_multi(ff, eval=eval)</code></pre><p>Register a multi-argument function so that it works with particles. If you want to register functions from within a module, you must pass the modules <code>eval</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/register_primitive.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.register_primitive_single" href="#MonteCarloMeasurements.register_primitive_single"><code>MonteCarloMeasurements.register_primitive_single</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">register_primitive_single(ff, eval=eval)</code></pre><p>Register a single-argument function so that it works with particles. If you want to register functions from within a module, you must pass the modules <code>eval</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/register_primitive.jl#L84-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.ribbonplot" href="#MonteCarloMeasurements.ribbonplot"><code>MonteCarloMeasurements.ribbonplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ribbonplot(x,y,[q=0.025]; N=true)</code></pre><p>Plots a vector of particles with a ribbon covering quantiles <code>q, 1-q</code>. If <code>q::Tuple</code>, then you can specify both lower and upper quantile, e.g., <code>(0.01, 0.99)</code>.</p><p>If a positive number <code>N</code> is provided, <code>N</code> sample trajectories will be plotted on top of the ribbon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/plotting.jl#L18-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.set_comparison_function-Tuple{Any}" href="#MonteCarloMeasurements.set_comparison_function-Tuple{Any}"><code>MonteCarloMeasurements.set_comparison_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_comparison_function(f)</code></pre><p>Change the Function used to reduce particles to a number for comparison operators Toggle the use of a comparison Function without warning using the Function <code>unsafe_comparisons</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/MonteCarloMeasurements.jl#L80-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.sigmapoints-Tuple{Any, AbstractMatrix}" href="#MonteCarloMeasurements.sigmapoints-Tuple{Any, AbstractMatrix}"><code>MonteCarloMeasurements.sigmapoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sigmapoints(m, Σ)
sigmapoints(d::Normal)
sigmapoints(d::MvNormal)</code></pre><p>The <a href="https://en.wikipedia.org/wiki/Unscented_transform#Sigma_points">unscented transform</a> uses a small number of points to propagate the first and second moments of a probability density, called <em>sigma points</em>. We provide a function <code>sigmapoints(μ, Σ)</code> that creates a <code>Matrix</code> of <code>2n+1</code> sigma points, where <code>n</code> is the dimension. This can be used to initialize any kind of <code>AbstractParticles</code>, e.g.:</p><pre><code class="language-julia">julia&gt; m = [1,2]

julia&gt; Σ = [3. 1; 1 4]

julia&gt; p = StaticParticles(sigmapoints(m,Σ))
2-element Array{StaticParticles{Float64,5},1}:
 (5 StaticParticles: 1.0 ± 1.73)
 (5 StaticParticles: 2.0 ± 2.0)

julia&gt; cov(p) ≈ Σ
true

julia&gt; mean(p) ≈ m
true</code></pre><p>Make sure to pass the variance (not std) as second argument in case <code>μ</code> and <code>Σ</code> are scalars.</p><p><strong>Caveat</strong></p><p>If you are creating several one-dimensional uncertain values using sigmapoints independently, they will be strongly correlated. Use the multidimensional constructor! Example:</p><pre><code class="language-julia">p = StaticParticles(sigmapoints(1, 0.1^2))               # Wrong!
ζ = StaticParticles(sigmapoints(0.3, 0.1^2))             # Wrong!
ω = StaticParticles(sigmapoints(1, 0.1^2))               # Wrong!

p,ζ,ω = StaticParticles(sigmapoints([1, 0.3, 1], 0.1^2)) # Correct</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/sigmapoints.jl#L1-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.systematic_sample" href="#MonteCarloMeasurements.systematic_sample"><code>MonteCarloMeasurements.systematic_sample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">systematic_sample([rng::AbstractRNG,] N, d=Normal(0,1); permute=true)</code></pre><p>returns a <code>Vector</code> of length <code>N</code> sampled systematically from the distribution <code>d</code>. If <code>permute=false</code>, this vector will be sorted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/sampling.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.transform_moments-Tuple{Any, Any, Any}" href="#MonteCarloMeasurements.transform_moments-Tuple{Any, Any, Any}"><code>MonteCarloMeasurements.transform_moments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Y = transform_moments(X::Matrix, m, Σ; preserve_latin=false)</code></pre><p>Transforms <code>X</code> such that it get the specified mean and covariance.</p><pre><code class="language-julia">m, Σ   = [1,2], [2 1; 1 4] # Desired mean and covariance
particles = transform_moments(X, m, Σ)
julia&gt; cov(particles) ≈ Σ
true</code></pre><p><strong>Note</strong>, if <code>X</code> is a latin hypercube and <code>Σ</code> is non-diagonal, then the latin property is destroyed for all dimensions but the first. We provide a method <code>preserve_latin=true</code>) which absolutely preserves the latin property in all dimensions, but if you use this, the covariance of the sample will be slightly wrong</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/sigmapoints.jl#L48-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.unsafe_comparisons" href="#MonteCarloMeasurements.unsafe_comparisons"><code>MonteCarloMeasurements.unsafe_comparisons</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unsafe_comparisons(onoff=true; verbose=true)</code></pre><p>Toggle the use of a comparison function without warning. By default <code>mean</code> is used to reduce particles to a floating point number for comparisons. This function can be changed, example: <code>set_comparison_function(median)</code></p><pre><code class="language-none">unsafe_comparisons(mode=:reduction; verbose=true)</code></pre><p>One can also specify a comparison mode, <code>mode</code> can take the values <code>:safe, :montecarlo, :reduction</code>. <code>:safe</code> is the same as calling <code>unsafe_comparisons(false)</code> and <code>:reduction</code> corresponds to <code>true</code>.</p><p>See <a href="https://baggepinnen.github.io/MonteCarloMeasurements.jl/stable/#Comparison-mode-1">Documentation: Comparison mode</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/MonteCarloMeasurements.jl#L58-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.wasserstein-Tuple{AbstractParticles, AbstractParticles, Any}" href="#MonteCarloMeasurements.wasserstein-Tuple{AbstractParticles, AbstractParticles, Any}"><code>MonteCarloMeasurements.wasserstein</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wasserstein(p1::AbstractParticles,p2::AbstractParticles,p)</code></pre><p>Returns the Wasserstein distance (Earth-movers distance) of order <code>p</code>, to the <code>p</code>th power, between <code>p1</code> and <code>p2</code>. I.e., for <code>p=2</code>, this returns W₂²</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/distances.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.with_nominal-Tuple{AbstractParticles, Any}" href="#MonteCarloMeasurements.with_nominal-Tuple{AbstractParticles, Any}"><code>MonteCarloMeasurements.with_nominal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pn = with_nominal(p, val)</code></pre><p>Endow particles <code>p</code> with a nominal value <code>val</code>. The particle closest to <code>val</code> will be replaced with val, and moved to index 1. This operation introduces a slight bias in the statistics of <code>pn</code>, but the operation is asymptotically unbiased for large sample sizes. To obtain the nominal value of <code>pn</code>, call <code>nominal(pn)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/nominal.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.with_workspace-Tuple{Any, Any}" href="#MonteCarloMeasurements.with_workspace-Tuple{Any, Any}"><code>MonteCarloMeasurements.with_workspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">with_workspace(f,P)</code></pre><p>In some cases, defining a primitive function which particles are to be propagate through is not possible but allowing unsafe comparisons are not acceptable. One such case is functions that internally calculate eigenvalues of uncertain matrices. The eigenvalue calculation makes use of comparison operators. If the uncertainty is large, eigenvalues might change place in the sorted list of returned eigenvalues, completely ruining downstream computations. For this we recommend, in order of preference</p><ol><li>Use <code>@bymap</code> detailed <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl#monte-carlo-simulation-by-mappmap">in the documentation</a>. Applicable if all uncertain values appears as arguments to your entry function.</li><li>Create a <code>Workspace</code> object and call it using your entry function. Applicable if uncertain parameters appear nested in an object that is an argument to your entry function:</li></ol><pre><code class="language-julia"># desired computation: y = f(obj), obj contains uncertain parameters inside
y = with_workspace(f, obj)
# or equivalently
w = Workspace(f, obj)
use_invokelatest = true # Set this to false to gain 0.1-1 ms, at the expense of world-age problems if w is created and used in the same function.
w(obj, use_invokelatest)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/deconstruct.jl#L334-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.ℂ2ℂ_function-Union{Tuple{T}, Tuple{F}, Tuple{F, Complex{T}}} where {F&lt;:Union{DataType, Function}, T&lt;:AbstractParticles}" href="#MonteCarloMeasurements.ℂ2ℂ_function-Union{Tuple{T}, Tuple{F}, Tuple{F, Complex{T}}} where {F&lt;:Union{DataType, Function}, T&lt;:AbstractParticles}"><code>MonteCarloMeasurements.ℂ2ℂ_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ℂ2ℂ_function(f::Function, z::Complex{&lt;:AbstractParticles})</code></pre><p>Helper function for uncertainty propagation through complex-valued functions of complex arguments. applies <code>f : ℂ → ℂ</code> to <code>z::Complex{&lt;:AbstractParticles}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/complex.jl#L24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.ℝⁿ2ℂⁿ_function-Union{Tuple{N}, Tuple{T}, Tuple{F}, Tuple{F, AbstractArray{Particles{T, N}}}} where {F, T, N}" href="#MonteCarloMeasurements.ℝⁿ2ℂⁿ_function-Union{Tuple{N}, Tuple{T}, Tuple{F}, Tuple{F, AbstractArray{Particles{T, N}}}} where {F, T, N}"><code>MonteCarloMeasurements.ℝⁿ2ℂⁿ_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ℝⁿ2ℂⁿ_function(f::Function, p::AbstractArray{T})</code></pre><p>Helper function for performing uncertainty propagation through complex-valued functions with vector inputs. Applies  <code>f : ℝⁿ → Cⁿ</code> to an array of particles. E.g., <code>LinearAlgebra.eigvals(p::Matrix{&lt;:AbstractParticles}) = ℝⁿ2ℂⁿ_function(eigvals,p)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/particles.jl#L255-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.ℝⁿ2ℂⁿ_function-Union{Tuple{N}, Tuple{T}, Tuple{F}, Tuple{F, AbstractArray{StaticParticles{T, N}}}} where {F, T, N}" href="#MonteCarloMeasurements.ℝⁿ2ℂⁿ_function-Union{Tuple{N}, Tuple{T}, Tuple{F}, Tuple{F, AbstractArray{StaticParticles{T, N}}}} where {F, T, N}"><code>MonteCarloMeasurements.ℝⁿ2ℂⁿ_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ℝⁿ2ℂⁿ_function(f::Function, p::AbstractArray{T})</code></pre><p>Helper function for performing uncertainty propagation through complex-valued functions with vector inputs. Applies  <code>f : ℝⁿ → Cⁿ</code> to an array of particles. E.g., <code>LinearAlgebra.eigvals(p::Matrix{&lt;:AbstractParticles}) = ℝⁿ2ℂⁿ_function(eigvals,p)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/particles.jl#L255-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.ℝⁿ2ℝⁿ_function-Union{Tuple{N}, Tuple{T}, Tuple{F}, Tuple{F, AbstractArray{Particles{T, N}}}} where {F, T, N}" href="#MonteCarloMeasurements.ℝⁿ2ℝⁿ_function-Union{Tuple{N}, Tuple{T}, Tuple{F}, Tuple{F, AbstractArray{Particles{T, N}}}} where {F, T, N}"><code>MonteCarloMeasurements.ℝⁿ2ℝⁿ_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ℝⁿ2ℝⁿ_function(f::Function, p::AbstractArray{T})</code></pre><p>Helper function for performing uncertainty propagation through vector-valued functions with vector inputs. Applies  <code>f : ℝⁿ → ℝⁿ</code> to an array of particles. E.g., <code>Base.log(p::Matrix{&lt;:AbstractParticles}) = ℝⁿ2ℝⁿ_function(log,p)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/particles.jl#L235-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.ℝⁿ2ℝⁿ_function-Union{Tuple{N}, Tuple{T}, Tuple{F}, Tuple{F, AbstractArray{StaticParticles{T, N}}}} where {F, T, N}" href="#MonteCarloMeasurements.ℝⁿ2ℝⁿ_function-Union{Tuple{N}, Tuple{T}, Tuple{F}, Tuple{F, AbstractArray{StaticParticles{T, N}}}} where {F, T, N}"><code>MonteCarloMeasurements.ℝⁿ2ℝⁿ_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ℝⁿ2ℝⁿ_function(f::Function, p::AbstractArray{T})</code></pre><p>Helper function for performing uncertainty propagation through vector-valued functions with vector inputs. Applies  <code>f : ℝⁿ → ℝⁿ</code> to an array of particles. E.g., <code>Base.log(p::Matrix{&lt;:AbstractParticles}) = ℝⁿ2ℝⁿ_function(log,p)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/particles.jl#L235-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.@bymap-Tuple{Any}" href="#MonteCarloMeasurements.@bymap-Tuple{Any}"><code>MonteCarloMeasurements.@bymap</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@bymap f(p, args...)</code></pre><p>Call <code>f</code> with particles or vectors of particles by using <code>map</code>. This can be utilized if registering <code>f</code> using <a href="#MonteCarloMeasurements.register_primitive"><code>register_primitive</code></a> fails. See also <a href="#MonteCarloMeasurements.Workspace"><code>Workspace</code></a> if <code>bymap</code> fails.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/bymap.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.@bypmap-Tuple{Any}" href="#MonteCarloMeasurements.@bypmap-Tuple{Any}"><code>MonteCarloMeasurements.@bypmap</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@bypmap f(p, args...)</code></pre><p>Call <code>f</code> with particles or vectors of particles by using parallel <code>pmap</code>. This can be utilized if registering <code>f</code> using <a href="#MonteCarloMeasurements.register_primitive"><code>register_primitive</code></a> fails. See also <a href="#MonteCarloMeasurements.Workspace"><code>Workspace</code></a> if <code>bymap</code> fails.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/bymap.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.@prob-Tuple{Any}" href="#MonteCarloMeasurements.@prob-Tuple{Any}"><code>MonteCarloMeasurements.@prob</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@prob a &lt; b</code></pre><p>Calculate the probability that an event on any of the forms <code>a &lt; b, a &gt; b, a &lt;= b, a &gt;= b</code> occurs, where <code>a</code> and/or <code>b</code> are of type <code>AbstractParticles</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/bymap.jl#L121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonteCarloMeasurements.@unsafe-Tuple{Any}" href="#MonteCarloMeasurements.@unsafe-Tuple{Any}"><code>MonteCarloMeasurements.@unsafe</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@unsafe expression</code></pre><p>Activates unsafe comparisons for the provided expression only. The expression is surrounded by a try/catch block to robustly restore unsafe comparisons in case of exception.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/MonteCarloMeasurements.jl#L93-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:≈-Tuple{AbstractParticles, AbstractParticles}" href="#Base.:≈-Tuple{AbstractParticles, AbstractParticles}"><code>Base.:≈</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">p1 ≈ p2</code></pre><p>Determine if two particles are not significantly different</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/particles.jl#L533-L537">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:≉-Tuple{AbstractParticles, AbstractParticles}" href="#Base.:≉-Tuple{AbstractParticles, AbstractParticles}"><code>Base.:≉</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">p1 ≉ p2</code></pre><p>Determine if two particles are significantly different</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/a683e035307d8530778d7dda539b96b0b53f0340/src/particles.jl#L556-L560">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../advanced_usage/">« Advanced usage</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 6 January 2025 06:39">Monday 6 January 2025</span>. Using Julia version 1.10.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
