<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Supporting new functions · MonteCarloMeasurements Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="MonteCarloMeasurements Documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit">MonteCarloMeasurements Documentation</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Supporting new functions</a><ul class="internal"><li><a class="tocitem" href="#Overloading-a-new-function-1"><span>Overloading a new function</span></a></li><li><a class="tocitem" href="#Monte-Carlo-simulation-by-map/pmap-1"><span>Monte-Carlo simulation by <code>map/pmap</code></span></a></li><li><a class="tocitem" href="#Array-to-array-functions-1"><span>Array-to-array functions</span></a></li><li><a class="tocitem" href="#Complex-functions-1"><span>Complex functions</span></a></li><li><a class="tocitem" href="#Difficult-cases-1"><span>Difficult cases</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../comparison/">Linear vs. Monte-Carlo uncertainty propagation</a></li><li><a class="tocitem" href="../performance/">Performance tips</a></li><li><a class="tocitem" href="../advanced_usage/">Advanced usage</a></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Supporting new functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Supporting new functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/master/docs/src/overloading.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Supporting-new-functions-1"><a class="docs-heading-anchor" href="#Supporting-new-functions-1">Supporting new functions</a><a class="docs-heading-anchor-permalink" href="#Supporting-new-functions-1" title="Permalink"></a></h1><h2 id="Overloading-a-new-function-1"><a class="docs-heading-anchor" href="#Overloading-a-new-function-1">Overloading a new function</a><a class="docs-heading-anchor-permalink" href="#Overloading-a-new-function-1" title="Permalink"></a></h2><p>If a method for <code>Particles</code> is not implemented for your function <code>yourfunc</code>, the pattern to register your function looks like this</p><pre><code class="language-julia">register_primitive(yourfunc)</code></pre><p>This defines both a one-argument method and a multi-arg method for both <code>Particles</code> and <code>StaticParticles</code>. If you only want to define one of these, see <a href="../api/#MonteCarloMeasurements.register_primitive_single"><code>register_primitive_single</code></a>/<a href="../api/#MonteCarloMeasurements.register_primitive_multi"><code>register_primitive_multi</code></a>. If the function is from base or stdlib, you can just add it to the appropriate list in the source and submit a PR :)</p><h2 id="Monte-Carlo-simulation-by-map/pmap-1"><a class="docs-heading-anchor" href="#Monte-Carlo-simulation-by-map/pmap-1">Monte-Carlo simulation by <code>map/pmap</code></a><a class="docs-heading-anchor-permalink" href="#Monte-Carlo-simulation-by-map/pmap-1" title="Permalink"></a></h2><p>Some functions will not work when the input arguments are of type <code>Particles</code>. For this kind of function, we provide a fallback onto a traditional <code>map(f,p.particles)</code>. The only thing you need to do is to decorate the function call with the function <a href="../api/#MonteCarloMeasurements.bymap-Union{Tuple{F}, Tuple{F, Vararg{Any, N} where N}} where F"><code>bymap</code></a> or the macro <a href="../api/#MonteCarloMeasurements.@bymap-Tuple{Any}"><code>@bymap</code></a> like so:</p><pre><code class="language-julia">f(x) = 3x^2
p = 1 ± 0.1
r = @bymap f(p) # bymap(f,p) may give better error traces</code></pre><p>We further provide the macro <a href="../api/#MonteCarloMeasurements.@bypmap-Tuple{Any}"><code>@bypmap</code></a> (and <a href="../api/#MonteCarloMeasurements.bypmap-Union{Tuple{F}, Tuple{F, Vararg{Any, N} where N}} where F"><code>bypmap</code></a>) which does exactly the same thing, but with a <code>pmap</code> (parallel map) instead, allowing you to run several invocations of <code>f</code> in a distributed fashion.</p><p>These utilities will map the function <code>f</code> over each element of <code>p::Particles{T,N}</code>, such that <code>f</code> is only called with arguments of type <code>T</code>, e.g., <code>Float64</code>. This handles arguments that are multivaiate particles <code>&lt;: Vector{&lt;:AbstractParticles}</code> as well.</p><p>These utilities will typically be slower than calling <code>f(p)</code>. If <code>f</code> is very expensive, <a href="../api/#MonteCarloMeasurements.@bypmap-Tuple{Any}"><code>@bypmap</code></a> might prove prove faster than calling <code>f</code> with <code>p</code>, it&#39;s worth a try. The usual caveats for distributed computing applies, all code must be loaded on all workers etc.</p><h2 id="Array-to-array-functions-1"><a class="docs-heading-anchor" href="#Array-to-array-functions-1">Array-to-array functions</a><a class="docs-heading-anchor-permalink" href="#Array-to-array-functions-1" title="Permalink"></a></h2><p>These functions might not work with <code>Particles</code> out of the box. Special cases are currently implemented for</p><ul><li><code>exp : ℝ(n×n) → ℝ(n×n)</code>   matrix exponential</li><li><code>log : ℝ(n×n) → C(n×n)</code>   matrix logarithm</li><li><code>eigvals : ℝ(n×n) → C(n)</code> <strong>warning</strong>: eigenvalues are sorted, when two eigenvalues cross, this function is nondifferentiable. Eigenvalues can thus appear to have dramatically widened distributions. Make sure you interpret the result of this call in the right way.</li></ul><p>The function  <a href="../api/#MonteCarloMeasurements.ℝⁿ2ℝⁿ_function-Union{Tuple{N}, Tuple{T}, Tuple{F}, Tuple{F, AbstractArray{Particles{T, N}, N1} where N1}} where {F, T, N}"><code>ℝⁿ2ℝⁿ_function</code></a><code>(f::Function, p::AbstractArray{T})</code> applies <code>f : ℝⁿ → ℝⁿ</code> to an array of particles. See also <a href="../api/#MonteCarloMeasurements.ℝⁿ2ℂⁿ_function-Union{Tuple{N}, Tuple{T}, Tuple{F}, Tuple{F, AbstractArray{Particles{T, N}, N1} where N1}} where {F, T, N}"><code>ℝⁿ2ℂⁿ_function</code></a> which is used to implement, e.g., <code>log,eigvals</code></p><h2 id="Complex-functions-1"><a class="docs-heading-anchor" href="#Complex-functions-1">Complex functions</a><a class="docs-heading-anchor-permalink" href="#Complex-functions-1" title="Permalink"></a></h2><p>These functions do not work with <code>Particles</code> out of the box. Special cases are currently implemented for</p><ul><li><code>sqrt</code>, <code>exp</code>, <code>sin</code>, <code>cos</code></li></ul><p>We also provide in-place versions of the above functions, e.g.,</p><ul><li><code>sqrt!(out, p)</code>, <code>exp!(out, p)</code>, <code>sin!(out, p)</code>, <code>cos!(out, p)</code></li></ul><p>The function <a href="../api/#MonteCarloMeasurements.ℂ2ℂ_function-Union{Tuple{T}, Tuple{F}, Tuple{F, Complex{T}}} where {F&lt;:Union{DataType, Function}, T&lt;:AbstractParticles}"><code>ℂ2ℂ_function</code></a><code>(f::Function, z)</code> (<code>ℂ2ℂ_function!(f::Function, out, z)</code>) applies <code>f : ℂ → ℂ</code> to <code>z::Complex{&lt;:AbstractParticles}</code>.</p><h2 id="Difficult-cases-1"><a class="docs-heading-anchor" href="#Difficult-cases-1">Difficult cases</a><a class="docs-heading-anchor-permalink" href="#Difficult-cases-1" title="Permalink"></a></h2><p>Sometimes, defining a primitive function can be difficult, such as when the uncertain parameters are baked into some object. In such cases, we can call the function <a href="../api/#MonteCarloMeasurements.unsafe_comparisons"><code>unsafe_comparisons</code></a><code>(true)</code>, which defines all comparison operators for uncertain values to compare using the <code>mean</code>. Note however that this enabling this is somewhat <em>unsafe</em> as this corresponds to a fallback to linear uncertainty propagation, why it&#39;s turned off by default. We also provide the macro <code>@unsafe ex</code> to enable mean comparisons only locally in the expression <code>ex</code>.</p><p>In some cases, defining a primitive is not possible but allowing unsafe comparisons are not acceptable. One such case is functions that internally calculate eigenvalues of uncertain matrices. The eigenvalue calculation makes use of comparison operators. If the uncertainty is large, eigenvalues might change place in the sorted list of returned eigenvalues, completely ruining downstream computations. For this we recommend, in order of preference</p><ol><li>Use <a href="../api/#MonteCarloMeasurements.bymap-Union{Tuple{F}, Tuple{F, Vararg{Any, N} where N}} where F"><code>bymap</code></a>. Applicable if all uncertain values appears as arguments to your entry function.</li><li>Create a <a href="../api/#MonteCarloMeasurements.Workspace"><code>Workspace</code></a> object and call it using your entry function. Applicable if uncertain parameters appear nested in an object that is an argument to your entry function:</li></ol><pre><code class="language-julia"># desired computation: y = f(obj), obj contains uncertain parameters inside
y = with_workspace(f, obj)
# or equivalently
w = Workspace(f,obj) # This is somewhat expensive and can be reused
use_invokelatest = true # Set this to false to gain 0.1-1 ms, at the expense of world-age problems if w is created and used in the same function.
w(obj, use_invokelatest)</code></pre><p>This interface is so far not tested very well and may throw strange errors. Some care has been taken to make error messages informative. Internally, a <code>w::Workspace</code> object is created that tries to automatically construct an object identical to <code>obj</code>, but where all uncertain parameters are replaced by conventional <code>Real</code>. If the heuristics used fail, an error message is displayed detailing which method you need to implement to make it work. When called, <code>w</code> populates the internal buffer object with particle <code>i</code>, calls <code>f</code> using a <code>Particles</code>-free <code>obj</code> and stores the result in an output object at particle index  <code>i</code>. This is done for <code>i ∈ 1:N</code> after which the output is returned. Some caveats include: <a href="../api/#MonteCarloMeasurements.Workspace"><code>Workspace</code></a> must not be created or used inside a <code>@generated</code> function.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../examples/">Examples »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 1 October 2023 10:39">Sunday 1 October 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
